"use strict";
/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const is = require("is");
const semver = require("semver");
const shimmer = require("shimmer");
const url = require("url");
// tslint:disable:no-any
const isString = is.string;
// url.URL is used for type checking, but doesn't exist in Node <7.
// This function works around that.
const isURL = semver.satisfies(process.version, '>=7') ?
    ((value) => value instanceof url.URL) :
    ((value) => false);
// tslint:enable:no-any
function getSpanName(options) {
    // c.f. _http_client.js ClientRequest constructor
    return options.hostname || options.host || 'localhost';
}
function extractUrl(options, fallbackProtocol) {
    let path;
    if (isURL(options)) {
        // pathname only exists on a URL object.
        path = options.pathname || '/';
    }
    else {
        const agent = options._defaultAgent;
        if (agent) {
            fallbackProtocol = agent.protocol || fallbackProtocol;
        }
        // path only exists on a ClientRequestArgs object.
        path = options.path || '/';
    }
    const protocol = options.protocol || fallbackProtocol;
    const host = options.hostname || options.host || 'localhost';
    const portString = options.port ? (':' + options.port) : '';
    // In theory we should use url.format here. However, that is
    // broken. See: https://github.com/joyent/node/issues/9117 and
    // https://github.com/nodejs/io.js/pull/893
    // Let's do things the same way _http_client does it.
    return `${protocol}//${host}${portString}${path}`;
}
// tslint:disable-next-line:no-any
function isTraceAgentRequest(options, api) {
    return options && options.headers &&
        !!options.headers[api.constants.TRACE_AGENT_REQUEST_HEADER];
}
function makeRequestTrace(protocol, request, api) {
    // On Node 8+ we use the following function to patch both request and get.
    // Here `request` may also happen to be `get`.
    return function requestTrace(options, callback) {
        if (!options) {
            return request(options, callback);
        }
        // Don't trace ourselves lest we get into infinite loops
        // Note: this would not be a problem if we guarantee buffering
        // of trace api calls. If there is no buffering then each trace is
        // an http call which will get a trace which will be an http call
        if (isTraceAgentRequest(options, api)) {
            return request(options, callback);
        }
        let uri;
        if (isString(options)) {
            // save the value of uri so we don't have to reconstruct it later
            uri = options;
            options = url.parse(options);
        }
        const span = api.createChildSpan({ name: getSpanName(options) });
        if (!api.isRealSpan(span)) {
            return request(options, callback);
        }
        if (!uri) {
            uri = extractUrl(options, protocol);
        }
        const method = options.method || 'GET';
        span.addLabel(api.labels.HTTP_METHOD_LABEL_KEY, method);
        span.addLabel(api.labels.HTTP_URL_LABEL_KEY, uri);
        const req = request(options, (res) => {
            api.wrapEmitter(res);
            let numBytes = 0;
            let listenerAttached = false;
            // Responses returned by http#request are yielded in paused mode.
            // Attaching a 'data' listener to the request will switch the stream to
            // flowing mode which could cause the request to drain before the calling
            // framework has a chance to attach their own listeners. To avoid this, we
            // attach our listener lazily. This approach to tracking data size will
            // not observe data read by explicitly calling `read` on the request. We
            // expect this to be very uncommon as it is not mentioned in any of the
            // official documentation.
            shimmer.wrap(res, 'on', (on) => {
                return function on_trace(eventName) {
                    if (eventName === 'data' && !listenerAttached) {
                        listenerAttached = true;
                        on.call(this, 'data', (chunk) => {
                            numBytes += chunk.length;
                        });
                    }
                    return on.apply(this, arguments);
                };
            });
            res.on('end', () => {
                span.addLabel(api.labels.HTTP_RESPONSE_SIZE_LABEL_KEY, numBytes);
                span.addLabel(api.labels.HTTP_RESPONSE_CODE_LABEL_KEY, res.statusCode);
                span.endSpan();
            });
            if (callback) {
                return callback(res);
            }
        });
        api.wrapEmitter(req);
        req.setHeader(api.constants.TRACE_CONTEXT_HEADER_NAME, span.getTraceContext());
        req.on('error', error => {
            span.addLabel(api.labels.ERROR_DETAILS_NAME, error.name);
            span.addLabel(api.labels.ERROR_DETAILS_MESSAGE, error.message);
            span.endSpan();
        });
        return req;
    };
}
function patchHttp(http, api) {
    shimmer.wrap(http, 'request', (request) => {
        return makeRequestTrace('http:', request, api);
    });
    if (semver.satisfies(process.version, '>=8.0.0')) {
        // http.get in Node 8 calls the private copy of request rather than the one
        // we have patched on module.export, so patch get as well.
        shimmer.wrap(http, 'get', () => {
            // Re-implement http.get. This needs to be done (instead of using
            // makeRequestTrace to patch it) because we need to set the trace
            // context header before the returned ClientRequest is ended.
            // The Node.js docs state that the only differences between request and
            // get are that (1) get defaults to the HTTP GET method and (2) the
            // returned request object is ended immediately.
            // The former is already true (at least in supported Node versions up to
            // v9), so we simply follow the latter.
            // Ref:
            // https://nodejs.org/dist/latest/docs/api/http.html#http_http_get_options_callback
            return function getTrace(options, callback) {
                const req = http.request(options, callback);
                req.end();
                return req;
            };
        });
    }
}
// https.get depends on Node http internals in 8.9.0 and 9+ instead of the
// public http module.
function patchHttps(https, api) {
    shimmer.wrap(https, 'request', (request) => {
        return makeRequestTrace('https:', request, api);
    });
    shimmer.wrap(https, 'get', function getWrap() {
        return function getTrace(options, callback) {
            const req = https.request(options, callback);
            req.end();
            return req;
        };
    });
}
function unpatchHttp(http) {
    shimmer.unwrap(http, 'request');
    if (semver.satisfies(process.version, '>=8.0.0')) {
        shimmer.unwrap(http, 'get');
    }
}
function unpatchHttps(https) {
    shimmer.unwrap(https, 'request');
    shimmer.unwrap(https, 'get');
}
const plugin = [
    {
        file: 'http',
        patch: patchHttp,
        unpatch: unpatchHttp,
    },
    {
        file: 'https',
        versions: '<8.9.0 || ^8.9.1',
        // require http if it wasn't patched yet, because the https client uses
        // the public 'http' module.
        patch: () => require('http')
    },
    {
        file: 'https',
        versions: '=8.9.0 || >=9.0.0',
        patch: patchHttps,
        unpatch: unpatchHttps,
    }
];
module.exports = plugin;
//# sourceMappingURL=plugin-http.js.map