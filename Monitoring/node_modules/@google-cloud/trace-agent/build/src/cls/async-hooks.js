"use strict";
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const shimmer = require("shimmer");
// A list of well-known EventEmitter methods that add event listeners.
const EVENT_EMITTER_METHODS = ['addListener', 'on', 'once', 'prependListener', 'prependOnceListener'];
// A symbol used to check if a method has been wrapped for context.
const WRAPPED = Symbol('@google-cloud/trace-agent:AsyncHooksCLS:WRAPPED');
/**
 * An implementation of continuation-local storage on top of the async_hooks
 * module.
 */
class AsyncHooksCLS {
    constructor(defaultContext) {
        this.defaultContext = defaultContext;
        this.contexts = {};
        this.enabled = false;
        this.currentContext = { value: this.defaultContext };
        this.hook = require('async_hooks').createHook({
            init: (id, type, triggerId, resource) => {
                this.contexts[id] = this.currentContext.value;
            },
            before: (id) => {
                if (this.contexts[id]) {
                    this.currentContext.value = this.contexts[id];
                }
            },
            destroy: (id) => {
                delete this.contexts[id];
            }
        });
    }
    isEnabled() {
        return this.enabled;
    }
    enable() {
        this.currentContext.value = this.defaultContext;
        this.hook.enable();
        this.enabled = true;
    }
    disable() {
        this.currentContext.value = this.defaultContext;
        this.hook.disable();
        this.enabled = false;
    }
    getContext() {
        return this.currentContext.value;
    }
    setContext(value) {
        this.currentContext.value = value;
    }
    runWithNewContext(fn) {
        const oldContext = this.currentContext.value;
        this.currentContext.value = this.defaultContext;
        try {
            return fn();
        }
        finally {
            this.currentContext.value = oldContext;
        }
    }
    bindWithCurrentContext(fn) {
        if (fn[WRAPPED] || !this.currentContext) {
            return fn;
        }
        const current = this.currentContext;
        const boundContext = this.currentContext.value;
        const contextWrapper = function () {
            const oldContext = current.value;
            current.value = boundContext;
            try {
                return fn.apply(this, arguments);
            }
            finally {
                current.value = oldContext;
            }
        };
        contextWrapper[WRAPPED] = true;
        Object.defineProperty(contextWrapper, 'length', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: fn.length
        });
        return contextWrapper;
    }
    // This function is not technically needed and all tests currently pass
    // without it (after removing call sites). While it is not a complete
    // solution, restoring correct context before running every request/response
    // event handler reduces the number of situations in which userspace queuing
    // will cause us to lose context.
    patchEmitterToPropagateContext(ee) {
        const that = this;
        EVENT_EMITTER_METHODS.forEach((method) => {
            if (ee[method]) {
                shimmer.wrap(ee, method, (oldMethod) => {
                    return function (event, cb) {
                        return oldMethod.call(this, event, that.bindWithCurrentContext(cb));
                    };
                });
            }
        });
    }
}
exports.AsyncHooksCLS = AsyncHooksCLS;
//# sourceMappingURL=async-hooks.js.map